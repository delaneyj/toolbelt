{% func GenerateCRUD(t *GenerateCRUDTable) %}
// Code generated by "sqlc-gen-zombiezen". DO NOT EDIT.

package {%s t.PackageName.Lower %}

import (
    "fmt"
    "zombiezen.com/go/sqlite"
    "github.com/delaneyj/toolbelt"
)

type {%s t.SingleName.Pascal %}Model struct {
    {%- for _,f := range t.Fields -%}
        {%s f.Name.Pascal %} {% if f.IsNullable %}*{% endif %}{%s f.GoType.Original %} `json:"{%s f.Name.Lower %}"`
    {%- endfor -%}
}


type Create{%s t.SingleName.Pascal %}Stmt struct {
    stmt *sqlite.Stmt
}

func Create{%s t.SingleName.Pascal %}(tx *sqlite.Conn) *Create{%s t.SingleName.Pascal %}Stmt {
    stmt := tx.Prep(`
INSERT INTO {%s t.Name.Lower %} (
    {%- for i,f := range t.Fields -%}
        {%s f.Name.Lower %}{% if i < len(t.Fields) - 1 %},{% endif %}
    {%- endfor -%}
) VALUES (
    {%- for i :=  range t.Fields -%}
        ?{% if i < len(t.Fields) - 1 %},{% endif %}
    {%- endfor -%}
)
    `)
    return &Create{%s t.SingleName.Pascal %}Stmt{stmt: stmt}
}

func (ps *Create{%s t.SingleName.Pascal %}Stmt) Run(m *{%s t.SingleName.Pascal %}Model) error {
    defer ps.stmt.Reset()

    // Bind parameters
    {%= bindFields(t) %}

    if _, err := ps.stmt.Step(); err != nil {
        return fmt.Errorf("failed to insert {%s t.Name.Lower %}: %w", err)
    }

    return nil
}

func OnceCreate{%s t.SingleName.Pascal %}(tx *sqlite.Conn, m *{%s t.SingleName.Pascal %}Model) error {
    ps := Create{%s t.SingleName.Pascal %}(tx)
    return ps.Run(m)
}

type ReadAll{%s t.Name.Pascal %}Stmt struct {
    stmt *sqlite.Stmt
}

func ReadAll{%s t.Name.Pascal %}(tx *sqlite.Conn) *ReadAll{%s t.Name.Pascal %}Stmt {
    stmt := tx.Prep(`
SELECT
    {%- for i,f := range t.Fields -%}
        {%s f.Name.Lower %}{% if i < len(t.Fields) - 1 %},{% endif %}
    {%- endfor -%}
FROM {%s t.Name.Lower %}
    `)
    return &ReadAll{%s t.Name.Pascal %}Stmt{stmt: stmt}
}

func (ps *ReadAll{%s t.Name.Pascal %}Stmt) Run() ([]*{%s t.SingleName.Pascal %}Model, error) {
    defer ps.stmt.Reset()

    var models []*{%s t.SingleName.Pascal %}Model
    for {
        hasRow, err := ps.stmt.Step()
        if err != nil {
            return nil, fmt.Errorf("failed to read {%s t.Name.Lower %}: %w", err)
        } else if !hasRow {
            break
        }

        m := &{%s t.SingleName.Pascal %}Model{}
        {%= fillResStruct(t) %}

        models = append(models, m)
    }

    return models, nil
}

func OnceReadAll{%s t.Name.Pascal %}(tx *sqlite.Conn) ([]*{%s t.SingleName.Pascal %}Model, error) {
    ps := ReadAll{%s t.Name.Pascal %}(tx)
    return ps.Run()
}

{%- if t.HasID -%}
type ReadByID{%s t.SingleName.Pascal %}Stmt struct {
    stmt *sqlite.Stmt
}

func ReadByID{%s t.SingleName.Pascal %}(tx *sqlite.Conn) *ReadByID{%s t.SingleName.Pascal %}Stmt {
    stmt := tx.Prep(`
SELECT
    {%- for i,f := range t.Fields -%}
        {%s f.Name.Lower %}{% if i < len(t.Fields) - 1 %},{% endif %}
    {%- endfor -%}
FROM {%s t.Name.Lower %}
WHERE id = ?
    `)
    return &ReadByID{%s t.SingleName.Pascal %}Stmt{stmt: stmt}
}

func (ps *ReadByID{%s t.SingleName.Pascal %}Stmt) Run(id int64) (*{%s t.SingleName.Pascal %}Model, error) {
    defer ps.stmt.Reset()

    ps.stmt.BindInt64(1, id)

    if hasRow, err := ps.stmt.Step(); err != nil {
        return nil, fmt.Errorf("failed to read {%s t.Name.Lower %}: %w", err)
    } else if !hasRow {
        return nil, nil
    }

    m := &{%s t.SingleName.Pascal %}Model{}
    {%= fillResStruct(t) %}

    return m, nil
}

func OnceReadByID{%s t.SingleName.Pascal %}(tx *sqlite.Conn, id int64) (*{%s t.SingleName.Pascal %}Model, error) {
    ps := ReadByID{%s t.SingleName.Pascal %}(tx)
    return ps.Run(id)
}
{%- endif -%}

func Count{%s t.Name.Pascal %}(tx *sqlite.Conn) (int64, error) {
    stmt := tx.Prep(`
SELECT COUNT(*)
FROM {%s t.Name.Lower %}
    `)
    defer stmt.Reset()

    if hasRow, err := stmt.Step(); err != nil {
        return 0, fmt.Errorf("failed to count {%s t.Name.Lower %}: %w", err)
    } else if !hasRow {
        return 0, nil
    }

    return stmt.ColumnInt64(0), nil
}

func OnceCount{%s t.Name.Pascal %}(tx *sqlite.Conn) (int64, error) {
    return Count{%s t.Name.Pascal %}(tx)
}

type Update{%s t.SingleName.Pascal %}Stmt struct {
    stmt *sqlite.Stmt
}

func Update{%s t.SingleName.Pascal %}(tx *sqlite.Conn) *Update{%s t.SingleName.Pascal %}Stmt {
    stmt := tx.Prep(`
UPDATE {%s t.Name.Lower %}
SET
    {%- for i,f := range t.Fields -%}
        {%- if i > 0 -%}
        {%s f.Name.Lower %} = ?{%d i +1 %}{% if i < len(t.Fields) - 1 %},{% endif %}
        {%- endif -%}
    {%- endfor -%}
WHERE id = ?1
    `)
    return &Update{%s t.SingleName.Pascal %}Stmt{stmt: stmt}
}

func (ps *Update{%s t.SingleName.Pascal %}Stmt) Run(m *{%s t.SingleName.Pascal %}Model) error {
    defer ps.stmt.Reset()

    // Bind parameters
    {%= bindFields(t) %}

    if _, err := ps.stmt.Step(); err != nil {
        return fmt.Errorf("failed to update {%s t.Name.Lower %}: %w", err)
    }

    return nil
}

func OnceUpdate{%s t.SingleName.Pascal %}(tx *sqlite.Conn, m *{%s t.SingleName.Pascal %}Model) error {
    ps := Update{%s t.SingleName.Pascal %}(tx)
    return ps.Run(m)
}

type Delete{%s t.SingleName.Pascal %}Stmt struct {
    stmt *sqlite.Stmt
}

func Delete{%s t.SingleName.Pascal %}(tx *sqlite.Conn) *Delete{%s t.SingleName.Pascal %}Stmt {
    stmt := tx.Prep(`
DELETE FROM {%s t.Name.Lower %}
WHERE id = ?
    `)
    return &Delete{%s t.SingleName.Pascal %}Stmt{stmt: stmt}
}

func (ps *Delete{%s t.SingleName.Pascal %}Stmt) Run(id int64) error {
    defer ps.stmt.Reset()

    ps.stmt.BindInt64(1, id)

    if _, err := ps.stmt.Step(); err != nil {
        return fmt.Errorf("failed to delete {%s t.Name.Lower %}: %w", err)
    }

    return nil
}

func OnceDelete{%s t.SingleName.Pascal %}(tx *sqlite.Conn, id int64) error {
    ps := Delete{%s t.SingleName.Pascal %}(tx)
    return ps.Run(id)
}

{% endfunc %}

{%- func bindFields( tbl *GenerateCRUDTable) -%}
    {%- for col, f := range tbl.Fields -%}
        {%- if f.IsNullable -%}
    if m.{%s f.Name.Pascal %} == nil {
        ps.stmt.BindNull({%d col %})
    } else {
        {%= bindField(f, true) -%}
    }
        {%- else -%}
    {%= bindField(f,false) %}
        {%- endif -%}
    {%- endfor -%}
{%- endfunc -%}

{%- func bindField(f GenerateField, isNullable bool) -%}
    ps.{%- switch f.GoType.Original -%}
        {%-  case "time.Time" -%}
            stmt.Bind{%s f.SQLType.Pascal %}({%d f.Column %}, toolbelt.TimeToJulianDay({% if isNullable %}*{% endif %} m.{%s f.Name.Pascal %}))
        {%- case "time.Duration" -%}
            stmt.Bind{%s f.SQLType.Pascal %}({%d f.Column %}, toolbelt.DurationToMilliseconds({% if isNullable %}*{% endif %}m.{%s f.Name.Pascal %}))
        {%- default -%}
            stmt.Bind{%s f.SQLType.Pascal %}({%d f.Column %}, {% if isNullable %}*{% endif %}m.{%s f.Name.Pascal %})
    {%- endswitch -%}
{%- endfunc -%}

{%- func fillResStruct(t *GenerateCRUDTable) -%}

{%- for i,f := range t.Fields -%}
    {%- if f.IsNullable -%}
    if ps.stmt.ColumnIsNull({%d i %}) {
        m.{%s f.Name.Pascal %} = nil
    } else {
        tmp :=  {%= fillResStructField(f, i) -%}
        m.{%s f.Name.Pascal %} = &tmp
    }
    {%- else -%}
    m.{%s f.Name.Pascal %} = {%= fillResStructField(f,i) %}
    {%- endif -%}
{%- endfor -%}
{%- endfunc -%}

{%- func fillResStructField(f GenerateField, i int) -%}
    {%- switch f.GoType.Original -%}
        {%- case "time.Time" -%}
            toolbelt.JulianDayToTime(ps.stmt.Column{%s f.SQLType.Pascal %}({%d i %}))
        {%- case "time.Duration" -%}
            toolbelt.MillisecondsToDuration(ps.stmt.Column{%s f.SQLType.Pascal %}({%d i %}))
        {%- case "[]byte" -%}
            toolbelt.StmtBytesByCol(ps.stmt, {%d i %})
        {%- default -%}
            ps.stmt.Column{%s f.SQLType.Pascal %}({%d i %})
    {%- endswitch -%}
{%- endfunc -%}