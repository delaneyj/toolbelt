{% func GenerateQuery(q *GenerateQueryContext) %}
// Code generated by "sqlc-gen-zombiezen". DO NOT EDIT.

package {%s q.PackageName.Lower %}

import (
    "fmt"
    "zombiezen.com/go/sqlite"

    {% if q.HasSliceParams %}
    "strings"
    {% endif %}

    {% if q.NeedsTimePackage %}
    "time"
    "github.com/delaneyj/toolbelt"
    {% endif %}
)

{% if q.HasResponse && !q.ResponseIsSingularField %}
type {%s q.Name.Pascal %}Res struct {
    {%- for _,f := range q.ResponseFields -%}
        {%s f.Name.Pascal %} {% if f.IsNullable %}*{% endif %}{%s f.GoType.Original %} `json:"{%s f.Name.Lower %}"`
    {%- endfor -%}
}
{% endif %}

{% if q.HasParams && !q.ParamsIsSingularField %}
type {%s q.Name.Pascal %}Params struct {
    {%- for _,f := range q.Params -%}
        {%s f.Name.Pascal %} {% if f.IsNullable %}*{% endif %}{%s f.GoType.Original %} `json:"{%s f.Name.Lower %}"`
    {%- endfor -%}
}
{% endif %}

type {%s q.Name.Pascal %}Stmt struct {
    conn      *sqlite.Conn
    stmt      *sqlite.Stmt
    querySQL  string
    hasSlices bool
}

func {%s q.Name.Pascal %}(tx *sqlite.Conn) *{%s q.Name.Pascal %}Stmt {
    const querySQL = `
{%s= q.SQL %}
    `

    ps := &{%s q.Name.Pascal %}Stmt{
        conn:     tx,
        querySQL: querySQL,
        hasSlices: {% if q.HasSliceParams %}true{% else %}false{% endif %},
    }

    if !ps.hasSlices {
        ps.stmt = tx.Prep(querySQL)
    }

    return ps
}

func (ps *{%s q.Name.Pascal %}Stmt) Run(
    {%= fillReqParams(q) -%}
) (
    {%= fillReturns(q) -%}
) {
    querySQL := ps.querySQL

{%- if q.HasSliceParams -%}
    {%= declareSlices(q, q.ParamsIsSingularField) %}
{%- endif -%}

    var stmt *sqlite.Stmt
    if ps.hasSlices {
        stmt = ps.conn.Prep(querySQL)
    } else {
        stmt = ps.stmt
    }

    defer func() {
        _ = stmt.ClearBindings()
        _ = stmt.Reset()
    }()

{%- if len(q.Params) > 0 -%}
    bindIndex := 1
    // Bind parameters
    {%= bindParams(q, q.ParamsIsSingularField) %}
{%- endif -%}

    // Execute the query
{%- if q.HasResponse -%}
    {%- if q.ResponseHasMultiple -%}
        for {
            if hasRow, err := stmt.Step(); err != nil {
                return res, fmt.Errorf("failed to execute {{.Name.Lower}} SQL: %w", err)
            } else if !hasRow {
                break
            }

            {%- if q.ResponseIsSingularField -%}
            {%s q.ResponseFields[0].Name.Camel %} := {%= fillResponse(q) -%}
            res = append(res, {%s q.ResponseFields[0].Name.Camel %})
            {%- else -%}
            {%= fillResponse(q) -%}
            res = append(res, row)
            {%- endif -%}
        }
    {%- else -%}
        if hasRow, err := stmt.Step(); err != nil {
            {%- if q.ResponseIsSingularField -%}
            return res, fmt.Errorf("failed to execute {{.Name.Lower}} SQL: %w", err)
            {%- else -%}
            return res, fmt.Errorf("failed to execute {{.Name.Lower}} SQL: %w", err)
            {%- endif -%}
        } else if hasRow {
            {%- if q.ResponseIsSingularField -%}
            res = {%= fillResponse(q) -%}
            {%- else -%}
            {%= fillResponse(q) -%}
            res = &row
            {%- endif -%}
        }
    {%- endif -%}
{%- else -%}
    if _, err := stmt.Step(); err != nil {
        return fmt.Errorf("failed to execute {%s q.Name.Lower %} SQL: %w", err)
    }
{%- endif -%}

{%- if q.HasResponse -%}
    return res, nil
{%- else -%}
    return nil
{%- endif -%}
}

func Once{%s q.Name.Pascal %}(
    tx *sqlite.Conn,
    {%= fillReqParams(q) -%}
) (
    {%= fillReturns(q) -%}
) {
    ps := {%s q.Name.Pascal %}(tx)

    return ps.Run(
    {%- if q.HasParams -%}
        {% if q.ParamsIsSingularField -%}
            {%s q.Params[0].Name.Camel -%} ,
        {%- else -%}
            params,
        {%- endif -%}
    {%- endif %}
    )
}

{% endfunc %}

{%- func fillResponse(q *GenerateQueryContext) -%}
{%- if q.ResponseIsSingularField -%}
    {%- code
        f := q.ResponseFields[0]
     -%}
    {%- switch f.GoType.Original -%}
        {%- case "time.Time" -%}
            toolbelt.JulianDayToTime(stmt.ColumnFloat({%d f.Offset %}))
        {%- case "time.Duration" -%}
            toolbelt.MillisecondsToDuration(stmt.ColumnInt64({%d f.Offset %}))
        {%- case "[]byte" -%}
            toolbelt.StmtBytesByCol(stmt, {%d f.Offset %}),
        {%- default -%}
            stmt.Column{%s f.SQLType.Pascal %}({%d f.Offset %})
    {%- endswitch -%}
{%- else -%}
    row := {%s q.Name.Pascal %}Res{}
    {%- for _,f := range q.ResponseFields -%}
        {%- if f.IsNullable -%}
            isNull{%s f.Name.Pascal %} := stmt.ColumnIsNull({%d f.Offset %})
            if !isNull{%s f.Name.Pascal %} {
                tmp := {%= fillResponseField(f) -%}
                row.{%s f.Name.Pascal %} = &tmp
            }
        {%- else -%}
            row.{%s f.Name.Pascal %} = {%= fillResponseField(f) -%}
        {%- endif -%}
    {%- endfor -%}
{%- endif -%}
{%- endfunc -%}

{%- func fillResponseField(f GenerateField) -%}
{%- switch f.GoType.Original -%}
    {%- case "time.Time" -%}
        toolbelt.JulianDayToTime(stmt.ColumnFloat({%d f.Offset %}))
    {%- case "time.Duration" -%}
        toolbelt.MillisecondsToDuration(stmt.ColumnInt64({%d f.Offset %}))
    {%- case "[]byte" -%}
        toolbelt.StmtBytesByCol(stmt, {%d f.Offset %})
    {%- default -%}
        stmt.Column{%s f.SQLType.Pascal %}({%d f.Offset %})
{%- endswitch -%}
{%- endfunc -%}

{%- func fillReqParams(q *GenerateQueryContext) -%}
{%- if q.HasParams -%}
    {%- if q.ParamsIsSingularField -%}
        {%s q.Params[0].Name.Camel %}  {% if q.Params[0].IsNullable %}*{% endif %}{%s q.Params[0].GoType.Original -%},
    {%- else -%}
        params {%s q.Name.Pascal %}Params,
    {%- endif -%}
{%- endif -%}
{%- endfunc  -%}


{%- func fillReturns(q *GenerateQueryContext) -%}
{%- if q.HasResponse -%}
    {%- if q.ResponseIsSingularField -%}
        res {% if q.ResponseHasMultiple %}[]{% endif %}{%s q.ResponseFields[0].GoType.Original -%},
    {%- else -%}
        res {% if q.ResponseHasMultiple %}[]{% else %}*{% endif %}{%s q.Name.Pascal %}Res,
    {%- endif -%}
{%- endif -%}
    err error,
{%- endfunc -%}

{%- func declareSlices(q *GenerateQueryContext, isSingle bool) -%}
{%- for _,p := range q.Params -%}
    {%- if p.IsSlice -%}
        {%- code
accessor := p.Name.Camel
if !isSingle {
    accessor = "params." + p.Name.Pascal
}
sliceVar := "slice" + p.Name.Pascal
        -%}
    {%s sliceVar %} := {%s accessor %}
    if len({%s sliceVar %}) > 0 {
        querySQL = strings.Replace(querySQL, "/*SLICE:{%s p.OriginalName %}*/?", strings.Repeat(",?", len({%s sliceVar %}))[1:], 1)
    } else {
        querySQL = strings.Replace(querySQL, "/*SLICE:{%s p.OriginalName %}*/?", "NULL", 1)
    }
    {%- endif -%}
{%- endfor -%}
{%- endfunc -%}

{%- func bindParams(q *GenerateQueryContext, isSingle bool) -%}
{%- for _,p := range q.Params -%}
    {%- if p.IsSlice -%}
        {%- code
sliceVar := "slice" + p.Name.Pascal
        -%}
    if len({%s sliceVar %}) > 0 {
        for _, elem := range {%s sliceVar %} {
            {%= bindValueWithExpr(p, "elem") %}
            bindIndex++
        }
    }
    {%- else -%}
        {%- code
accessor := p.Name.Camel
if !isSingle {
    accessor = "params." + p.Name.Pascal
}
        -%}
        {%- if p.IsNullable -%}
    if {%s accessor %} == nil {
        stmt.BindNull(bindIndex)
    } else {
        {%= bindValueWithExpr(p, "*" + accessor) %}
    }
    bindIndex++
        {%- else -%}
    {%= bindValueWithExpr(p, accessor) %}
    bindIndex++
        {%- endif -%}
    {%- endif -%}
{%- endfor -%}
{%- endfunc -%}

{%- func bindValueWithExpr(p GenerateField, value string) -%}
{%- switch p.BindGoType.Original -%}
    {%- case "time.Time" -%}
        stmt.Bind{%s p.SQLType.Pascal %}(bindIndex, toolbelt.TimeToJulianDay({%s value %}))
    {%- case "time.Duration" -%}
        stmt.Bind{%s p.SQLType.Pascal %}(bindIndex, toolbelt.DurationToMilliseconds({%s value %}))
    {%- default -%}
        stmt.Bind{%s p.SQLType.Pascal %}(bindIndex, {%s value %})
{%- endswitch -%}
{%- endfunc -%}
